SUMMARY

TODO:
1. La funció pthread_ret genera un page fault quan intenta agafar el valor de %eax (valor de retorn de la funció cridada) de la pila d'usuari.
2. La funció pthread_join no tinc molt clar com implementar-la per quan el procés encara no és zombie i hem d'esperar el resultat. Un cop despertem el thread que hem adormit hem de fer que torni a cridar a pthread_join? Com segueix la execució? Va baixant per la pila de kernel fins tornar a la funció i seguir???

WORKING:
1. Els semafors funcionen "aparentment" a la perfeció, totes les funcions provades
2. El sched ara si que va, abans podia posar el thread de idle a una ready queue o un thread a ready just després de que un semafor el bloquejes
3. Ara ja mai marquem un procés com a bloquejat (tal i com ho havies canviat ja), dóna problemes i ens farà perdre el temps :) per total poc temps que s'executi l'idle
4. La funció de pthread_exit va i copia bé el resultat de sortida a una variable
5. He intentat que pthread_exit i pthread_ret tinguesin la mateixa estructura, les dos acaben a zombify_and_wakeup(), només varia que en una posem el resultat al TCB del que ens passen per una variable i en l'altre ho agafem de la pila d'usuari

QUESTIONS:
1. A la funció de exit() es pot arribar amb més d'un thread? Jo pensava que ha de tirar un error si encara hi ha threads slave en el procés

NOTES:
* Ara mateix el tema del join i els exits esta implementat de manera que un thread slave al acabar allibera tot els recursos (pila usuari) exepte el TCB, de forma que el thread master en fer un join, pot recollir el resultat i sera el responsable de desvincular del procés el thread i agregar el TCB com a free. Diria que és similar a la implementació per defecte que té linux, com a mínim això del Zombie ens ho van explicar a SO